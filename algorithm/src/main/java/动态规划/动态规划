如果是求问题的最优解，且该问题可以分解成若干个子问题，并且子问题之间还有重叠的更小子问题，
就可以考虑用动态规划在应用动态规划之前要分析能否把大问题分解成小问题，分解后的每个小问题也存在最优解，
如果小问题的最优解能组合起来得到整个问题的最优解，那么就可以用动态规划解决这个问题

三个要素：状态转移、边界条件、自上而下

读懂最长公共子串、最大子串和、最长公共子序列、最长递增公共子序列

1. 最长公共子串：dp[i][j]表示前i、j字符为结尾组成的最长公共子串长度
2. 最大子串和：dp[i]表示以i字符为结尾组成的子串和
3. 最长公共子序列：dp[i][j]表示前i、j个字符组成的字符串的最长公共子序列
4. 最长递增公共子序列：dp[i][j]表示以i、j字符为结尾组成的最长递增公共子序列


一般来说，以字符串长度（第3种）或者以某个位置的字符作为结尾（第1、2、4种）是比较常见的状态转移放出。

对于最长公共子串来说，由于子串存在连续性，以某个位置的字符作为结尾为状态转移条件，如果s1[i] == s2[j]，那么dp[i][j] = dp[i - 1][j - 1] + 1
对于最大子串和来说，由于子串存在连续性，以某个位置的字符作为结尾为状态转移条件，如果dp[i - 1] <= 0，那么dp[i] = nums[i]，否则dp[i] = dp[i - 1] + nums[i]
对于最长公共子序列来说，由于子序列不具有连续性，以字符串长度作为状态转移条件，如果s1[i] == s2[j]，那么dp[i][j] = dp[i - 1][j - 1] + 1
对于最长递增子序列来说，虽然子序列不具有连续性，如果以字符串长度作为转移条件，我们无法知道s[i]该属于哪个递增序列，也就不知道dp[i]的值该依赖于哪一个状态，
需要消除这个不确定性，所以以某个位置的字符作为结尾为状态转移条件，从位置i向前遍历来确定最长递增子序列是哪个，dp[i] = max(dp[0...i])
